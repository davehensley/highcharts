/**
 * Highcharts Broken Axis plugin
 * 
 * Author: Torstein Honsi
 * License: MIT License
 *
 * Demo: http://jsfiddle.net/highcharts/Vf3yT/
 */

/*global HighchartsAdapter*/
(function (H) {	

	"use strict";

	var noop = function () {},
		floor = Math.floor,
		each = H.each,
		pick = H.pick,
		wrap = H.wrap,
		extend = H.extend,
 		fireEvent = HighchartsAdapter.fireEvent,
		Axis = H.Axis,
		Series = H.Series,
		noop = function () {};

	extend(Axis.prototype, {
		isInBreak: function (brk, val) {
			var	repeat = brk.repeat || Infinity,
				val = val % repeat,
				val2 = val + repeat,
				from = brk.from % repeat,
				to = from + (brk.to - brk.from);

			return ((val > from && val < to) || (val2 > from && val2 < to));
		},

		isInAnyBreak: function (val) {			
			if (!this.options.breaks) { return false; }
			
			var breaks = this.options.breaks,
				i = breaks.length;

			while (i--) {
				if (this.isInBreak(breaks[i], val)) {
					return true;
				}
			}
			return false
		}
	});
/*
	wrap(Axis.prototype, 'setTickPositions', function (proceed) {
		proceed.apply(this, Array.prototype.slice.call(arguments, 1));
		
		var axis = this,
			tickPositions = this.tickPositions,
			info = this.tickPositions.info,
			newPositions = [],
			i;

		for (i=0; i < tickPositions.length; i++) {
			if (!axis.isInAnyBreak(tickPositions[i])) {
				newPositions.push(tickPositions[i]);
			}
		}

		this.tickPositions = newPositions;
		this.tickPositions.info = info;
	});
*/
	/*
	wrap(Axis.prototype, 'init', function (proceed, chart, userOptions) {

		proceed.call(this, chart, userOptions);

		var axis = this;
		
		if (this.options.breaks) {
			var axis = this;
			axis.postTranslate = true;

			this.val2lin = function (val) {
				return val - axis.shifts[val];
			};
			
			this.lin2val = function (val) {
				return val + axis.shifts[val];
			};
			
			this.setAxisTranslation = function (saveOld) {
				Axis.prototype.setAxisTranslation.call(this, saveOld);
				
				var breaks = axis.options.breaks,
					brkPoints = axis.breakPoints = [],
					shifts = axis.shifts = {},
					min = Math.round(axis.userMin || axis.min),
					max = Math.round(axis.userMax || axis.max),
					shift = 0,
					inbrk = false,
					i;

				for (i = min; i <= max; i += axis.closestPointRange) {
					if (axis.isInAnyBreak(i)) {
						shift += axis.closestPointRange;
						inbrk = true;
					} else if (inbrk) { 
						shift += axis.closestPointRange;
						inbrk = false;
					}
					shifts[i] = shift;
				}

				var pre = null;
				
				inbrk = true;

				for (i in shifts) {
					if (shifts[i] == shifts[pre] && inbrk) {
						brkPoints.push(pre);
						inbrk = false;
					} else if (shifts[i] !== shifts[pre] && !inbrk) {
						 brkPoints.push(pre);
						 inbrk = true;
					}
					pre = i;
				}

				axis.transA *= (max - min) / (max - min - shift);
			};

		}
		
	});
	*/
		/*
	wrap(Axis.prototype, 'init', function (proceed, chart, userOptions) {

		proceed.call(this, chart, userOptions);

		if(this.options.breaks) {

			var axis = this;
			
			axis.postTranslate = true;

			this.val2lin = function (val) {
				if (axis.isInAnyBreak(val)) return null;

				var nval = val,
					shift = 0,
					i;
				for(i = 0; i < axis.breakArray.length; i++) {
					if (axis.breakArray[i].end < val) {
						shift += (axis.breakArray[i].len); // + (2 * axis.closestPointRange));
					} else if (axis.breakArray[i].start > val) {
						break;
					}
				}

				console.log(Highcharts.dateFormat('%d', val), ': ', shift / (24 * 3600 * 1000));
				if (shift == 0) {
					return nval;
				} else {
					return nval - shift;
				}
			};
			
			this.lin2val = function (val) {
				return val;
			};

			this.setAxisTranslation = function (saveOld) {				
				Axis.prototype.setAxisTranslation.call(this, saveOld);

				var breaks = axis.options.breaks,
					breakArrayT = [],	// Temporary one
					breakArray = [],
					length = 0, 
					inBrk,
					repeat,
					brk,
					end = axis.max,
					start,
					i,
					j;

				// Construct an array of arrays holding all breaks in the axis
				for (i in breaks) {
					brk = breaks[i];
					start = brk.from;
					repeat = brk.repeat || Infinity;

					while (start - repeat > axis.min) {
						start -= repeat;
					}
					while (start < axis.min) {
						start += repeat;
					}

					for (j = start; j < end; j += repeat) {
						breakArrayT.push({
							value: j,
							move: 'in'
						});
						breakArrayT.push({
							value: j + (brk.to - brk.from),
							move: 'out'
						});
					}
				}

				breakArrayT.sort(function (a, b) {
					return a.value - b.value;
				});
				
				// Simplify the breaks
				inBrk = 0;
				start = axis.min;

				for (i in breakArrayT) {
					brk = breakArrayT[i];
					inBrk += (brk.move === 'in' ? 1 : -1);

					if (inBrk === 1 && brk.move === 'in') {
						start = brk.value;
					} 
					if (inBrk === 0) {
						breakArray.push({
							start: start,
							end: brk.value,
							len: brk.value - start + axis.closestPointRange
						});
						length += brk.value - start; // + (2 * axis.closestPointRange);						
					}
				}

				axis.breakArray = breakArray;
				console.log(breakArray);

				axis.transA *= (axis.max - axis.min) / (axis.max - axis.min - length);

			};
		}

	});
	*/
	wrap(Series.prototype, 'generatePoints', function (proceed) {
		var series = this,
			data = this.options.data,
			ndata = [],
			xAxis = this.xAxis,
			i = 0,
			point;

		while(i < data.length) {
			point = data[i];
			if (!xAxis.isInAnyBreak(point.x)) {
				ndata.push(point);
			} 
			i++;
		}

		this.options.data = ndata;


		proceed.apply(this, Array.prototype.slice.call(arguments, 1));

	});


}(Highcharts));